<html>
<meta name="viewport" content="initial-scale=0.5">
<head>
    <link rel="stylesheet" href="styles.css">
    <title>c p p </title>
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css?family=Lora|Muli|Open+Sans|Raleway|Roboto+Condensed|Inconsolata|Libre+Franklin|Barlow|Roboto+Slab&display=swap');
    </style>
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
</head>

    <body>
        <div id="nav">

        </div>

        <script>
        $(function(){
          $("#nav").load("nav.html");
        });
        </script>



        <h1 id="realtime-title">Real-time</h1>

            <div class="break"></div>
            <div class="pg-descr"><p id="realtime-main-descr">I'm also interested in real-time rendering.
                I write small (very small) demos with OpenGL, often also using the Csound API to build in some kind of audio responsiveness.
                Also some real-time work with TouchDesigner.</p></div>
            <div class="break"></div>

        <div class="realtime-container">
            <canvas id="glCanvas_flow" width="640" height="360"></canvas>

            <div class="realtime-vid1"><iframe src="https://player.vimeo.com/video/382865759?byline=0&portrait=0&title=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div>
            <div class="realtime-vid1-descr"><p>Screen recording, OpenGL and Csound.
                    The terrain and the clouds are raymarched.
                    </p></div>

            <div class="realtime-vid2"><iframe src="https://player.vimeo.com/video/406051467?byline=0&portrait=0&title=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div>
            <div class="realtime-vid2-descr"><p>Screen reocrding, OpenGL.
                    Pretty simple particle system, some aging and attractors. It's based on one of the compute examples in the 2013 OpenGL programming guides.</p></div>

            <div class="realtime-vid3"><iframe src="https://player.vimeo.com/video/383017020?byline=0&portrait=0&title=0" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe></div>
            <div class="realtime-vid3-descr"><p>Another screen recording, OpenGL and Csound.
                    Here the audio responsiveness is in the foreground.</p></div>

            <div class="gl-descr"><p>WebGL. You can play and pause by tapping anywhere on the image.
                It's just time-dependent fbm noise, but after a lot of fiddling it ended up looking reasonably like a viscous fluid.
                Anyway I like the shader a lot so wanted to put it somewhere I'd be reminded of it.</p></div>
        </div>

    </body>

    <script>

    // play pause audio
    var firstLoad = true; // makes sure one frame is rendered at beginning
    // make logic to play and stop on click or touch
    var glPlay = false;
    var canvas = document.getElementById("glCanvas_flow");
    canvas.addEventListener("mousedown", function(e) {
        if (!glPlay) {glPlay = true;}
        else if (glPlay) {glPlay = false;}
    }, false);

    canvas.addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (!glPlay) {glPlay = true;}
        else if (glPlay) {glPlay = false;}
    }, false);

    </script>

    <script id="vertex.vert" type="text/glsl">
    attribute vec4 aVertexPosition;

    void main() {
        gl_Position = aVertexPosition;
    }
    </script>

    <script id="raymarch.frag" type="text/glsl">
    // so much here based on work and discussion at https://www.iquilezles.org/index.html.
    // also http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/.

    precision highp float;
    #pragma STDGL invariant(all);
    uniform float delt;

    const int MAX_MARCHING_STEPS = 1024;
    const float MIN_DIST = 0.0;
    const float MAX_DIST = 50.0;
    const float EPSILON = 0.001;

    // SOME VARIOUS NOISE FUNCTIONS

    // random function
    float random (in vec2 st) {
        return fract(sin(dot(st, vec2(24,80.233))) * 20.0);
    }

    //noise function
    float noise (in vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        vec2 u = f * f * (3.0 - 2.0 * f);

        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }

    // fbn noise
    #define NUM_OCTAVES 8

    float fbm ( in vec2 st ) {
        float v = 0.0;
        float a = 0.5;
        vec2 shift = vec2(100.0 + (delt * 0.3));
        // Rotate to reduce axial bias
        mat2 rot = mat2(cos(0.5), sin(0.5),
                        -sin(0.5), cos(0.50));
        for (int i = 0; i < NUM_OCTAVES; ++i) {
            v += a * noise(st);
            st = rot * st * 2.0 + shift;
            a *= 0.245;
        }
        return v;
    }

    // sphere SDF
    float sphereSDF( vec3 p ) {
        float noise = fbm(p.xz);
        return length(p) - 3.0;
    }

    float torusSDF( vec3 samplePoint, vec2 t ) {
        vec2 q = vec2(length(samplePoint.xz)-t.x, samplePoint.y);
        return length(q) - t.y;
    }

    float terrainSDF ( vec3 p ) {
        float terrainNoise = fbm(p.xy + fbm(p.xz)); // p.zy also looks good for the first
        return 0.4 - 0.4*sin(p.y*0.4 - cos(p.y*0.4)) + (terrainNoise * (0.4 + delt));
    }

    float terrain2DSDF ( vec2 p ) {
        float terrainNoise = fbm(p.xy + fbm(p.yx)); // p.zy also looks good for the first
        return 0.4 - 0.44*sin(p.y*0.4 - cos(p.y*0.4)) + (terrainNoise * 0.4);
    }

    float opRepSphere( vec3 p, vec3 c) {
        vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;
        return sphereSDF(q);
    }

    // scene SDF -- computes fields for the whole scene, maybe more than one shape!
    float sceneSDF( vec3 p ) {
        vec3 spacing = vec3(6.5); // spacing is for the repetition
        return terrainSDF(p);
    }
    // iq terrain intersect routine
    float terrainIntersect( vec3 eye, vec3 marchingDir, float tmin, float tmax ) {
        float t = tmin;
        for ( int i = 0; i < MAX_MARCHING_STEPS; i++ ) {
          vec3 pos =  eye + t * marchingDir;
          float h = pos.y - terrain2DSDF(pos.xz);
          if( (abs(h) < 0.002*t) || t>tmax ) {
              break;
              }
          t += 0.4*h;
        }
        return t;
    }

    // getting the ray direction
    vec3 rayDir( float FOV, vec2 resolution, vec2 fragcoord ) {
        vec2 xy = fragcoord - resolution / 2.0;
        float z = resolution.y  * 0.75 / tan(radians(FOV) / 2.0);
        return normalize(vec3(xy, -z));
    }

    // make some normals from the gradient -- "finite differences"
    vec3 estimateNormal( vec3 pos) {
        return normalize( vec3 (
          sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z)) - sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z)),
          sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z)) - sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z)),
          sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON)) - sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON))
          ));
    }

    // phong lighting contribution
    vec3 phongContribForLight( vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {
      vec3 N = estimateNormal(p);
      vec3 L = normalize(lightPos - p);
      vec3 V = normalize(eye - p);
      vec3 R = normalize(reflect(-L, N));

      float dotLN = clamp(dot(N, L), 0.0, 1.0);
      float dotRV = dot(R, V);
      if (dotLN < 0.0) {
        // light not visible from this samplePoint
        return vec3(0.0);
      }
      if (dotRV < 0.0) {
        return lightIntensity * (kd * dotLN);
      }
      return lightIntensity * (kd * dotLN + ks * pow(dotRV, alpha));
    }

    // lighting!
    vec3 phongIllumination( vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye) {
      const vec3 ambientLight = 0.75 * vec3(0.82, 0.2, 0.67);
      vec3 color = ambientLight * ka;
      vec3 light1Pos = vec3(-12.0, 20.0, 12.0);
      vec3 light1Intensity = vec3(0.75, 0.75, 0.75);
      color += phongContribForLight(kd, ks, alpha, p, eye, light1Pos, light1Intensity);
      return color;
    }

    // view matrix for camera rotations
    mat4 viewMatrix( vec3 eye, vec3 target, vec3 up) {
        vec3 f = normalize(target - eye);
        vec3 s = normalize(cross(f, up));
        vec3 u = cross(s, f);
        return mat4(
            vec4(s, 0.0),
            vec4(u, 0.0),
            vec4(-f, 0.0),
            vec4(0.0, 0.0, 0.0, 1.0)
        );
    }

    // MAIN IMAGE FUNCTION
    void main()
    {

        vec4 color = vec4(1.0);
        vec2 res = vec2(640,360);
        vec2 fragCoord = gl_FragCoord.xy;
        vec3 eyeStationary = vec3(0.0);
        vec3 eye = vec3(1.0 + delt * 0.05, 3.0, 1.0);
        // the ray direction, here moved into world space, will be the marching direction
        vec3 rayDir = rayDir(60.0, res.xy, fragCoord);
        mat4 viewToWorld = viewMatrix(eye, vec3(-1.0, -5.0, 0.0) + eye, vec3(0.0, 1.0, 0.0));
        vec3 worldDir = (viewToWorld * vec4(rayDir, 0.0)).xyz;

        //float dist = shortestDistToSurface(eye, worldDir, MIN_DIST, MAX_DIST); // 3D input
        float dist = terrainIntersect(eye, worldDir, MIN_DIST, MAX_DIST);
        /*
        if you hold eye stationary, normals stay the same, but y position is actually changing
        so it looks water kind of--surface deformed by waves. I think, right now I can't
        tell why it looks like moving water.

        figured it out: the surfacePos was still using rayDir, not worldDir
        i think did kind of like the other effect better
        */
        vec3 surfacePos = eye + dist * worldDir;
        vec3 N = estimateNormal(surfacePos);

        vec3 pct = vec3(surfacePos.y);
        pct.r = smoothstep(0.0, 1.0, surfacePos.y);
        vec3 colorA = vec3(0.4, 0.4, 0.4);
        vec3 colorB = vec3(1.0, 0.7, 1.0);
        //vec3 baseCol = mix(colorA, colorB, pct);
        vec3 baseCol = vec3(0.3);
        vec4 envCol = vec4(0.2);

        vec3 Ka = vec3(0.13, 0.15, 0.12); // Ka is ambient color
        vec3 Kd = baseCol; // Kd is diffuse color
        vec3 Ks = vec3(0.18, 0.8, 0.8);
        float shininess = 5.0;
        vec3 phongColor = phongIllumination(Ka, Kd, Ks, shininess, surfacePos, eye);

        if (dist > (MAX_DIST - EPSILON)) {
          // the ray didn't hit the shape
          color = envCol;
          //return;
        } else {
          color = vec4(phongColor, 1.0);
        }

        gl_FragColor = color;
    }
    </script>

    <script src="gl-matrix.js"></script>
    <script src="webgl_2.js"></script>
</html>
