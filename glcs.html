<html lang="eng">

<head>
    <link rel="stylesheet" href="styles.css">
    <title>cpp</title>
        <script src="js/csound_extended_short.js"></script>
        <script>
            csound_extended_module().then(function(module) {
                csound_extended = module;
                csound = new csound_extended.CsoundWebAudio();
                console.log("csound_extended_module: csound_extended.js has been loaded.\n");
                var msg = document.getElementById("cs-display");
                msg.innerHTML = "csound loaded";
            });
        </script>
    <p id="glcs-header">Csound runs in realtime and affects (realtime) Web GL.</p>
</head>

<body>
    <div class="boxes">

    <canvas id="glCanvas" width="640" height="480"></canvas>
<!-- CSOUND -->
    <script>
    // playing from Csound
        var handleMessage = function(message) {
            var messages_textarea = document.getElementById("console");
            var existing = messages_textarea.value;
            messages_textarea.value = message;
            messages_textarea.scrollTop = messages_textarea.scrollHeight;
        };
        console.log(handleMessage);

        window.onload=function(){
        const csPlay = document.querySelector('.csound-controls');
        var csd = document.getElementById('csd').value;
        csPlay.addEventListener('click', function() {

            if (typeof csound === 'undefined') {
                console.log("Csound is not yet loaded, wait a bit...");
                return;
            }
            // check if context is in suspended state (autoplay policy)
            else if (this.dataset.playing === 'false') {
                csound.Stop();
                csound.Reset();
                csound.CompileCsdText(csd);
                csound.Start();
                csound.Perform();
                this.dataset.playing = 'true';
            // if track is playing pause it
            } else if (this.dataset.playing === 'true') {
                csound.Stop();
                csound.Reset();
                this.dataset.playing = 'false';
            }
            let state = this.getAttribute('aria-checked') === "true" ? true : false;
            this.setAttribute( 'aria-checked', state ? "false" : "true" );
            }, false);
            }

        //csound.addEventListener('ended', () => {
        //    this.dataset.playing = 'false';
        //    this.setAttribute( "aria-checked", "false" );
        //}, false);


        var then = 0;
        var audioRms = 0.0;
        var audioRms1 = 0.0;

        function pollCsound(now) {
            now = now*0.001;
            const dt = now - then;
            then = now;
            if (typeof csound === 'undefined') {
                console.log("wait for it...");
            } else {
            audioRms = csound.GetControlChannel("rmsInstr1");
            audioRms1 = csound.GetControlChannel("rmsInstr2");
            }
            requestAnimationFrame(pollCsound);
        }
        requestAnimationFrame(pollCsound);

        </script>
<!-- AUDIO FILE -->
        <audio src="sound01022019.mp3" crossOrigin="anonymous"></audio>
        <script type="text/javascript">
        //playing from, analyzing audio from, sound file
            //console.clear();

            //const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioCtx = new(window.AudioContext || window.webkitAudioContext)();

            var audioElement = document.querySelector('audio');
            var track = audioCtx.createMediaElementSource(audioElement);
            var analyzer = audioCtx.createAnalyser();
            track.connect(analyzer);

            window.addEventListener("load",function(){
            const playButton = document.querySelector('.tape-controls-play');
            // play pause audio
            playButton.addEventListener('click', function() {
                // check if context is in suspended state (autoplay policy)
            	if (audioCtx.state === 'suspended') {
            		audioCtx.resume();
            	}
            	if (this.dataset.playing === 'false') {
            		audioElement.play();
            		this.dataset.playing = 'true';
            	// if track is playing pause it
            	} else if (this.dataset.playing === 'true') {
            		audioElement.pause();
            		this.dataset.playing = 'false';
            	}
            	let state = this.getAttribute('aria-checked') === "true" ? true : false;
            	this.setAttribute( 'aria-checked', state ? "false" : "true" );
            }, false);
            }, false);

            audioElement.addEventListener('ended', () => {
                playButton.dataset.playing = 'false';
                playButton.setAttribute( "aria-checked", "false" );
            }, false);


            analyzer.fftSize = 64;
            const bufferLength = analyzer.fftSize;
            var dataArray = new Uint8Array(bufferLength); // better as floats; floats crashes on mobile

            var then = 0.0;
            var mean = 0.0;
            var afRms = 0.0; // audiofile rms

            function getRMS(now) {
                var now = now*0.0001;
                const dt = now - then;
                then = now;
                dataArray.fill(0);

                analyzer.getByteTimeDomainData(dataArray);

                var square = 0.0;
                for (var i = 0; i < bufferLength; i++) {
                    var  v = dataArray[i];
                    v = v*v;
                    square += v;
                }

                mean = square*0.015625; // divide by 64
                afRms = Math.sqrt(mean);
                afRms *= 0.0019607; // divide by 512
                console.log(afRms);
                requestAnimationFrame(getRMS);
            }
            requestAnimationFrame(getRMS);

            track.connect(audioCtx.destination);
        </script>

    <!--<div class="csndCons"><textarea id='console'></textarea></div>-->
    <div class="header-text">
    <p id="description">
    **Realtime Csound is choppy on mobile, so try playing the file instead.
    The effect is less fine-grained (rms on the final mix,
    rather than individual instruments), but it works.</p>
    </div>
    <p id="cs-display"></p>

    <button data-playing="false" class="tape-controls-play" role="switch" aria-checked="false">
        <span>Play File</span></button>

    <button data-playing="false" class="csound-controls" role="switch" aria-checked="false">
        <span>Play Csound</span></button>

<div class="csndScore"><textarea id='csd' cols=75 rows=37>
<CsoundSynthesizer>
<CsOptions>
-odac -d
</CsOptions>
<CsInstruments>
;-------------------
sr=44100
; kr=1000
ksmps=16
nchnls=2
0dbfs=1.0
giFn        ftgen   3, 0, 1024, 10, 1
giWfn       ftgen   4, 0, 16384, 20, 3, 1
giSine      ftgen   0, 0, 2^10, 10, 1
giTanh      ftgen   2,0,257,"tanh",-5,5,0 ; tanh function
gaRvbSend   init  0
;-------------------
instr 1
kFreq   = 100
kFmd    = kFreq * 0.2
kgdur   = 0.05
kDens   = 10.0
iMaxOvr = 10
aGrain  grain3 kFreq+p4, 0, kFmd, 0, kgdur, kDens, iMaxOvr, 3, 4, 0, 0
aEnv    linseg 0, 0.01, 0.75, p3-0.6, 0.75, 0.04, 0, 0.75, 0
aSig    = aGrain*aEnv*0.5
kRms    rms aSig
            chnset kRms, "rmsInstr1"
            chnset aSig, "audio"
            chnset kgdur, "graindur"
outs aSig, aSig
iRvbSend = 0.6
gaRvbSend = gaRvbSend + (aSig*iRvbSend)
endin
;-------------------
instr 2
kFreq   = 100
kAmt    = 0.5
kCutf   expon 10000, p3, 20
;                 |att       |decay       |sustain     |rel |
aEnv    linseg 0, p3*0.3, 1, p3*0.2, 0.8, p3*0.2, 0.4, p3*0.3, 0
aOsc1   poscil aEnv, kFreq, giSine
aOsc2   poscil aEnv, kFreq+7, giSine
aDist   distort (aOsc1+aOsc2)*0.5, kAmt, giTanh
aFilt   butterlp aDist, kCutf
kRms    rms aFilt
        chnset kRms, "rmsInstr2"
outs    aDist*0.1, aDist*0.1
iRvbSend = 0.2
gaRvbSend = gaRvbSend + (aDist*iRvbSend)
endin
;-------------------
instr 3
kroomSize       init        0.85
kHFDamp         init        0.75
aRvbL, aRvbR    freeverb    gaRvbSend, gaRvbSend, kroomSize, kHFDamp
outs aRvbL, aRvbR
clear gaRvbSend
endin
</CsInstruments>
<CsScore>
    i   3   0       4000
    i   1   2       2.5     120
    i   2   4       3      500
    i   1   7      5.0     755
    i   1   6       5.0     250
    e
</CsScore>
</CsoundSynthesizer>
</textarea></div>
</div>
</body>

<script id="vertex.vert" type="text/glsl">
attribute vec4 aVertexPosition;

void main() {
    gl_Position = aVertexPosition;
}
</script>

<script id="raymarch.frag" type="text/glsl">
// so much here based on work and discussion at https://www.iquilezles.org/index.html.
// also http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/.

precision highp float;
#pragma STDGL invariant(all);
uniform float delt;
uniform float audioRms;
uniform float audioRms1;
uniform float afRms;

const int MAX_STEPS = 15000;
const float MIN_DIST = 0.0;
const float MAX_DIST = 2500.0;
const float thresh = 0.001;

float fit(float v, float omin, float omax, float nmin, float nmax) {
  return nmin + (v - omin) * (nmax - nmin) / (omax - omin);
}

mat3 rotateX( float angle) {
    float rad = radians(angle);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3(  1, 0,  0 ),
                            vec3(  0, c, -s ),
                            vec3(  0, s,  c )
                            );
    return mat;
}

mat3 rotateY( float angle) {
    float PI = 3.1415926535;
    float rad = angle * (PI/180.0);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3( c, 0, s ),
                            vec3( 0, 1, 0 ),
                            vec3(-s, 0, c )
                            );
    return mat;
}

mat3 rotateZ( float angle) {
    float PI = 3.1415926535;
    float rad = angle * (PI/180.0);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3(  c, -s,  0 ),
                            vec3(  s,  c,  0 ),
                            vec3(  0,  0,  1 )
                            );
    return mat;
}

float torusSDF( vec3 p, vec2 t ) {
    vec2 q = vec2(length(p.xz)-t.x, p.y);
    return length(q) - t.y;
}

float twistTor( vec3 p , vec2 t) { // divide by 1024
    float scaledAfRms = fit(afRms,0.23,0.3,0.0,0.4);
    float k = 2.5*audioRms+(audioRms1*2.0)+scaledAfRms;
    float c = cos(k*p.y);
    float s = sin(k*p.y);
    mat2 m = mat2(c,-s,s,c);
    vec3 q = vec3(m*p.xz,p.y);
    return torusSDF(q, t);
}

vec2 sceneSDF( vec3 p ) {
    mat3 rotX = rotateX(delt*40.0);
    mat3 rotZ = rotateZ(delt*30.0);
    vec3 transp = p + vec3(1.0+sin(delt)*2.0, 0.0, 2.0);
    vec3 rotP = rotX*rotZ*transp;
    vec2 result = vec2(twistTor(rotP, vec2(1.0)),  2.0);
    return result;
}

vec2 castRay( vec3 eye, vec3 dir, float start, float end )
{
    float depth = start;
    float objID = 0.0;
    float lastDepth = 0.0;
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec2 result = sceneSDF(eye + dir * depth);
        float dist = result.x;
        objID = result.y;

        if (dist < thresh) { // this is a hit
            return vec2((depth+lastDepth)*0.5, objID);
        }
        lastDepth = depth;
        depth += dist*0.35;

        if (depth > end) { // the march length is past the max
          return vec2(end, objID);
        }
    }
    return vec2(end, objID);
}

vec3 rayDir(vec2 uv, vec3 camPos, vec3 camTarget) // camTarget = camPos + camFront
{
    vec3 camForward = normalize(camTarget - camPos);
    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));

    float fPersp = 2.0; // FOV
    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);

    return vDir;
}

vec2 normScreenCoords(vec2 screenCoord, vec2 resolution)
{
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/resolution.y; // Correct for aspect ratio
    return result;
}

vec3 calcNormal( const vec3 pos, float depth)
{
    vec3 p = pos;
    vec2 e = vec2(0.005*depth,0.0);
    return normalize(  vec3(    (sceneSDF(p+e.xyy).x - sceneSDF(p-e.xyy).x),
                                (sceneSDF(p+e.yxy).x - sceneSDF(p-e.yxy).x),
                                (sceneSDF(p+e.yyx).x - sceneSDF(p-e.yyx).x)
                            )
                    );
}

void main() {
    vec2 res = vec2(640.0,480.0);
    vec2 fragCoord = gl_FragCoord.xy;
    vec2 screenUV = normScreenCoords(fragCoord, res);
    vec3 camPos = vec3(2.0,5.0,5.0);
    vec3 camFront = vec3(0.0,3.0,0.0);
    vec3 camTarget = camFront - camPos;
    vec3 rd = rayDir(screenUV, camPos, camTarget);

    float march_result = castRay(camPos, rd.xyz, MIN_DIST, MAX_DIST).x;
    float objID = castRay(camPos, rd, MIN_DIST, MAX_DIST).y;
    vec3 surfacePos = camPos + rd*march_result;

    float shininess = 4.0;
    vec3 lightDir = vec3(0.3, 0.9, 0.3);
    vec3 N = calcNormal(surfacePos, march_result);
    vec3 L = normalize(lightDir); //normalize(lightDir - surfacePos);
    vec3 V = normalize(camPos - surfacePos);
    vec3 R = normalize(reflect(-L, N));
    float NdotL = dot(N,L);
    float diffuse = clamp(NdotL, 0.0, 1.0);
    float specular = pow(dot(R,V), shininess);

    vec3 color = vec3(0.0);

    if (march_result > (MAX_DIST - thresh))
    { // the ray didn't hit anything
        color = vec3(0.5);
    }
    else
    { // the ray did hit something
        color += diffuse * vec3(0.2+audioRms);
        color += specular * vec3(1.0);
        color.b += clamp(sin(delt+audioRms), 0.0, 0.15);
    }
    gl_FragColor = vec4(color, 1.0);

}
</script>

<script src="gl-matrix.js"></script>
<script src="webgl.js"></script>

</html>
