<html lang="eng">

<head>
    <link rel="stylesheet" href="styles.css">
    <title>CPP</title>
        <script src="js/csound_extended_short.js"></script>
        <script>
            csound_extended_module().then(function(module) {
                csound_extended = module;
                csound = new csound_extended.CsoundWebAudio();
                console.log("csound_extended_module: csound_extended.js has been loaded.\n");
            });
        </script>
</head>

<body>
    <div class="boxes">
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <script>
        var handleMessage = function(message) {
            var messages_textarea = document.getElementById("console");
            var existing = messages_textarea.value;
            messages_textarea.value = message;
            messages_textarea.scrollTop = messages_textarea.scrollHeight;
        };
        console.log = handleMessage;
        var onPlayClick = function() {
            if (typeof csound === 'undefined') {
                console.log("Csound is not yet loaded, wait a bit...");
                return;
            }
            var csd = document.getElementById('csd').value;
            csound.Stop();
            csound.Reset();
            csound.CompileCsdText(csd);
            csound.Start();
            csound.Perform();
        };
        var onPlayStop = function() {
            csound.Stop();
            csound.Reset();
        };

        var then = 0;
        var audioRms = 0.0;
        var audioRms1 = 0.0;

        function poll(now) {
            now = now*0.001;
            const dt = now - then;
            then = now;
            var msg = document.getElementById("showRms");
            if (typeof csound === 'undefined') {
                console.log("wait for it...");
            } else {
            audioRms = csound.GetControlChannel("rmsInstr1");
            msg.innerHTML = audioRms;
            audioRms1 = csound.GetControlChannel("rmsInstr2");
            }
            requestAnimationFrame(poll);
        }
        requestAnimationFrame(poll);

        </script>
    <div class="csndCons"><textarea id='console' cols=80 rows=2></textarea></div>
    <div class="controlButts"><p><input id="play" type="button" value="Play" onclick="onPlayClick()">
        <input id="stop" type="button" value="Stop" onclick="onPlayStop()"></p></div>
    <div class="rmsDisp"><p id="showRms" font-size="9px" padding="0px"></p></div>

<div class="csndScore"><textarea id='csd' cols=80 rows=25>
<CsoundSynthesizer>
<CsOptions>
-odac -d
</CsOptions>
<CsInstruments>
;-------------------
sr=48000
; kr=1000
ksmps=16
nchnls=2
0dbfs=1.0
giFn        ftgen   3, 0, 1024, 10, 1
giWfn       ftgen   4, 0, 16384, 20, 3, 1
giSine      ftgen   0, 0, 2^10, 10, 1
giTanh      ftgen   2,0,257,"tanh",-5,5,0 ; tanh function
gaRvbSend   init  0
;-------------------
instr 1
kFreq   = 100
kFmd    = kFreq * 0.2
kgdur   = 0.05
kDens   = 10.0
iMaxOvr = 10
aGrain  grain3 kFreq+p4, 0, kFmd, 0, kgdur, kDens, iMaxOvr, 3, 4, 0, 0
aEnv    linseg 0, 0.01, 0.75, p3-0.6, 0.75, 0.04, 0, 0.75, 0
aSig    = aGrain*aEnv*0.5
kRms    rms aSig
            chnset kRms, "rmsInstr1"
            chnset aSig, "audio"
            chnset kgdur, "graindur"
outs aSig, aSig
iRvbSend = 0.6
gaRvbSend = gaRvbSend + (aSig*iRvbSend)
endin
;-------------------
instr 2
kFreq   = 100
kAmt    = 0.5
kCutf   expon 10000, p3, 20
;                 |att       |decay       |sustain     |rel |
aEnv    linseg 0, p3*0.3, 1, p3*0.2, 0.8, p3*0.2, 0.4, p3*0.3, 0
aOsc1   poscil aEnv, kFreq, giSine
aOsc2   poscil aEnv, kFreq+7, giSine
aDist   distort (aOsc1+aOsc2)*0.5, kAmt, giTanh
aFilt   butterlp aDist, kCutf
kRms    rms aFilt
        chnset kRms, "rmsInstr2"
outs    aDist*0.1, aDist*0.1
iRvbSend = 0.2
gaRvbSend = gaRvbSend + (aDist*iRvbSend)
endin
;-------------------
instr 3
kroomSize       init        0.85
kHFDamp         init        0.75
aRvbL, aRvbR    freeverb    gaRvbSend, gaRvbSend, kroomSize, kHFDamp
outs aRvbL, aRvbR
clear gaRvbSend
endin
</CsInstruments>
<CsScore>
    i   3   0       4000
    i   1   2       2.5     120
    i   2   4       3      500
    i   1   7      5.0     755
    i   1   6       5.0     250
    e
</CsScore>
</CsoundSynthesizer>
</textarea></div>
</div>
</body>

<script id="vertex.vert" type="text/glsl">
attribute vec4 aVertexPosition;

void main() {
    gl_Position = aVertexPosition;
}
</script>

<script id="raymarch.frag" type="text/glsl">
precision highp float;
#pragma STDGL invariant(all);
uniform float delt;
uniform float audioRms;
uniform float audioRms1;

const int MAX_STEPS = 15000;
const float MIN_DIST = 0.0;
const float MAX_DIST = 2500.0;
const float thresh = 0.001;

mat3 rotateX( float angle) {
    float rad = radians(angle);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3(  1, 0,  0 ),
                            vec3(  0, c, -s ),
                            vec3(  0, s,  c )
                            );
    return mat;
}

mat3 rotateY( float angle) {
    float PI = 3.1415926535;
    float rad = angle * (PI/180.0);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3( c, 0, s ),
                            vec3( 0, 1, 0 ),
                            vec3(-s, 0, c )
                            );
    return mat;
}

mat3 rotateZ( float angle) {
    float PI = 3.1415926535;
    float rad = angle * (PI/180.0);
    float c = cos(rad);
    float s = sin(rad);
    mat3 mat = mat3(
                            vec3(  c, -s,  0 ),
                            vec3(  s,  c,  0 ),
                            vec3(  0,  0,  1 )
                            );
    return mat;
}

float torusSDF( vec3 p, vec2 t ) {
    vec2 q = vec2(length(p.xz)-t.x, p.y);
    return length(q) - t.y;
}

float twistTor( vec3 p , vec2 t) {
    float k = 2.5*audioRms+(audioRms1*2.0);
    float c = cos(k*p.y);
    float s = sin(k*p.y);
    mat2 m = mat2(c,-s,s,c);
    vec3 q = vec3(m*p.xz,p.y);
    return torusSDF(q, t);
}

vec2 sceneSDF( vec3 p ) {
    mat3 rotX = rotateX(delt*40.0);
    mat3 rotZ = rotateZ(delt*30.0);
    vec3 transp = p + vec3(1.0+sin(delt)*2.0, 0.0, 2.0);
    vec3 rotP = rotX*rotZ*transp;
    vec2 result = vec2(twistTor(rotP, vec2(1.0)),  2.0);
    return result;
}

vec2 castRay( vec3 eye, vec3 dir, float start, float end )
{
    float depth = start;
    float objID = 0.0;
    float lastDepth = 0.0;
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec2 result = sceneSDF(eye + dir * depth);
        float dist = result.x;
        objID = result.y;

        if (dist < thresh) { // this is a hit
            return vec2((depth+lastDepth)*0.5, objID);
        }
        lastDepth = depth;
        depth += dist*0.35;

        if (depth > end) { // the march length is past the max
          return vec2(end, objID);
        }
    }
    return vec2(end, objID);
}

vec3 rayDir(vec2 uv, vec3 camPos, vec3 camTarget) // camTarget = camPos + camFront
{
    vec3 camForward = normalize(camTarget - camPos);
    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));

    float fPersp = 2.0; // FOV
    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);

    return vDir;
}

vec2 normScreenCoords(vec2 screenCoord, vec2 resolution)
{
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/resolution.y; // Correct for aspect ratio
    return result;
}

vec3 calcNormal( const vec3 pos, float depth)
{
    vec3 p = pos;
    vec2 e = vec2(0.005*depth,0.0);
    return normalize(  vec3(    (sceneSDF(p+e.xyy).x - sceneSDF(p-e.xyy).x),
                                (sceneSDF(p+e.yxy).x - sceneSDF(p-e.yxy).x),
                                (sceneSDF(p+e.yyx).x - sceneSDF(p-e.yyx).x)
                            )
                    );
}

void main() {
    vec2 res = vec2(640.0,480.0);
    vec2 fragCoord = gl_FragCoord.xy;
    vec2 screenUV = normScreenCoords(fragCoord, res);
    vec3 camPos = vec3(-10.0,5.0,10.0);
    vec3 camFront = vec3(0.0,5.0,0.0);
    vec3 camTarget = camFront - camPos;
    vec3 rd = rayDir(screenUV, camPos, camTarget);

    float march_result = castRay(camPos, rd.xyz, MIN_DIST, MAX_DIST).x;
    float objID = castRay(camPos, rd, MIN_DIST, MAX_DIST).y;
    vec3 surfacePos = camPos + rd*march_result;

    float shininess = 4.0;
    vec3 lightDir = vec3(0.3, 0.9, 0.3);
    vec3 N = calcNormal(surfacePos, march_result);
    vec3 L = normalize(lightDir); //normalize(lightDir - surfacePos);
    vec3 V = normalize(camPos - surfacePos);
    vec3 R = normalize(reflect(-L, N));
    float NdotL = dot(N,L);
    float diffuse = clamp(NdotL, 0.0, 1.0);
    float specular = pow(dot(R,V), shininess);

    vec3 color = vec3(0.0);

    if (march_result > (MAX_DIST - thresh))
    {
        color = vec3(0.5);
    } // the ray didn't hit anything
    else { // the ray did hit something
        color += diffuse * vec3(0.2+audioRms);
        color += specular * vec3(1.0);
        color.b += clamp(sin(delt+audioRms), 0.0, 0.15);
    }
    gl_FragColor = vec4(color, 1.0);

}
</script>

<script src="gl-matrix.js"></script>
<script src="webgl.js"></script>

</html>
